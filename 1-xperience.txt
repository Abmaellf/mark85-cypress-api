
		
		#########  GITHUB ##################  
		########## MONGODB #########################
		https://cloud.mongodb.com/v2/661ddfdc78089f3466691965#/clusters/detail/Cluster0

				usuario abmaelqax 
				senha Abmaelxperience
				banco de dados: markdb

				npm install mongodb

				mongodb+srv://abmaelqax:<password>@cluster0.nmaphmy.mongodb.net/
				mongodb+srv://abmaelqax:<password>@cluster0.nmaphmy.mongodb.net/?retryWrites=true&w=majority&appName=Cluster0


		##########  RABBITMQ
		https://api.cloudamqp.com/console/b80cb0de-9085-4d17-993f-6add4807a2e2/details

				amqps://yzolzakg:JvGoDhAcKum2XzXN84ip4szZJWFz0_dc@toad.rmq.cloudamqp.com/yzolzakg
				
				JvGoDhAcKum2XzXN84ip4szZJWFz0_dc




		#########  JAIMINHO MAIL
		https://ethereal.email/
		
		
		########################  INICIAR AS APLICAÇÕES   ####################
		####################			####################
		
		===   WEB
		Em app/web
			Executar o comandi npm run dev
			
			Endereço      http://localhost:3000/
			
		=== API
			Executar o comando npm run dev
			
			Endereço      http://localhost:3333/users

		=== EMAIL
			Executar o comando npm run dev
			
			
			
		
		
		####################     ERRO CASO OCORRA O ERRO ABAIXO              ########
		
				❯ npx cypress run
				No version of Cypress is installed in: /home/abmael/.cache/Cypress/13.7.3/Cypress

				Please reinstall Cypress by running: cypress install

				----------

				Cypress executable not found at: /home/abmael/.cache/Cypress/13.7.3/Cypress/Cypress

				----------

				Platform: linux-x64 (Ubuntu - 22.04)
				Cypress Version: 13.7.3
				❯ npx cypress run
				No version of Cypress is installed in: /home/abmael/.cache/Cypress/13.7.3/Cypress

				Please reinstall Cypress by running: cypress install

				----------

				Cypress executable not found at: /home/abmael/.cache/Cypress/13.7.3/Cypress/Cypress

				----------

				Platform: linux-x64 (Ubuntu - 22.04)
				Cypress Version: 13.7.3
				❯ npx cypress install
				Installing Cypress (version: 13.7.3)

	

		### Criar  o projeto node
		
		Criar a pasta mark85-cypress-api/
		
		npm init        ou  npm init -y
		
		
		Nome do projeto: mark85-cypress-api/
		command npx cypress run
		
		Executar o comando:
		
			npm i cypress -D
			
		Abrindo a interface grafica do cypress pela primeira vez
		
			npx cypress open

		#Escoher  a opção para E2E Testing
		
		# Configurações continuar
		
		# Escoher  o navegador
		
		#Create your first spec   e vamos clickar em Creae new spec
		
			Enter the path your new spec
			   cypress\e2e\spec.cy.js
			   
		# Vamos alterar o endereço para:
		
			cypress\e2e\users.cy.js
		
		## Vamos clicar em create spec
		
			Será criado um describ com um it padrão, e vamos fechar clicando no x pois não vamos executar
			
		###  Vamos acessar o projeto no vscode
		
			## Estrutura criada
			
				> cypress
				> node_modules
				   cypress.config.js
				   package-lock.json
				   package.json
				   
			## Apagar a pasta de downloads pois não precisaremos dela no momento
			
			
=============================================================================================================================		
==========================================================         17. Task com MongoDB              ====================================				

	### instanlando o driver do mongodb no node
	
	npm i mongodb		
					
	### Dentro da pasta suporte vamos criar um arquivo chamado mongo.js	
		Vamos fazer a nossa função de connexão e desconexão
	
	###  Vamos fazer a importação e criar uma constante quer será nossa URI
	
	

			import { MongoClient } from 'mongodb'
			//const{ MongoClient} = require ('monogodb')

			const mongoUri = 'mongodb+srv://abmaelqax:Abmaelxperience@cluster0.nmaphmy.mongodb.net/?
			retryWrites=true&w=majority&appName=Cluster0'
			
			
	### Vamos criar outra constante para se a nossa instancia do mongodb
	
		

			import { MongoClient } from 'mongodb'
			//const{ MongoClient} = require ('monogodb')

			const mongoUri = 'mongodb+srv://abmaelqax:Abmaelxperience@cluster0.nmaphmy.mongodb.net/markdb?
			retryWrites=true&w=majority&appName=Cluster0'

			const client = new MongoClient(mongoUri);
	
	### vamos criar a função para connectar
	
			

			import { MongoClient } from 'mongodb'
			//const{ MongoClient} = require ('monogodb')

			const mongoUri = 'mongodb+srv://abmaelqax:Abmaelxperience@cluster0.nmaphmy.mongodb.net/markdb
			?retryWrites=true&w=majority&appName=Cluster0'

			const client = new MongoClient(mongoUri);

			function connect() {
			    client.connect()

			    return client.db('markdb')
			}

	### Vamos criar a função para desconexão
	
			

			import { MongoClient } from 'mongodb'
			//const{ MongoClient} = require ('monogodb')

			const mongoUri = 'mongodb+srv://abmaelqax:Abmaelxperience@cluster0.nmaphmy.mongodb.net/markdb?
			retryWrites=true&w=majority&appName=Cluster0'

			const client = new MongoClient(mongoUri);

			function connect() {
			    client.connect()

			    return client.db('markdb')
			}

			function disconnect() {
			    client.disconnect()
			}	
		
	### Essa funções são assicrona portante temos que envolver com async antes da função e await na chamada do  metodo de conexão e desconexão	
		
		
			

				

		const{ MongoClient} = require ('monogodb')

		    const mongoUri = 'mongodb+srv://abmaelqax:Abmaelxperience@cluster0.nmaphmy.mongodb.net/markdb?
		    retryWrites=true&w=majority&appName=Cluster0'

		    const client = new MongoClient(mongoUri);

		    async function connect() {
		        await client.connect()

		        return client.db('markdb')
		    }

		    async function disconnect() {
		        await client.disconnect()
		    }
		module.exports = {connect, disconnect }


			}
			
	
		
	#### 	Ajustando o cypress,config.js
	
							
								
			const { defineConfig } = require("cypress");
			const {connect } = require('./cypress/support/mongo')


			module.exports = defineConfig({
			  e2e: {
			   async  setupNodeEvents(on, config) {
			      // implement node event listeners here

			      const db = await connect();

			      on('task', {

			       async deleteUser(email) {
			          const users = db.collection('users')
			          await users.deleteMany({email: email})
			          return null;
			        }
			      })
			    },
			    baseUrl: 'http://localhost:3333'
			  },
			});


	####   Deletando o dado em nosso teste
	
		describe('POST /users', () =>{
			  it('register a new user', ()=>{

			    const user = {
			        name: 'margo',
			        email: 'margo@hotmail.com',
			        password: '141620'
			    }

		             ++++    cy.task('deleteUser', user.email)

			    cy.request({
			      url: '/users',
			      method: 'POST',
			      body: user,
			      failOnStatusCode: false
			    }).then(response => {
			      expect(response.status).to.eq(200)
			    })
			  })
			})
		
		
	### Vamos pegar o resultado da requisição para validar se estamos de fato deletando
	
		describe('POST /users', () =>{
			  it('register a new user', ()=>{

			    const user = {
			        name: 'margo',
			        email: 'margo@hotmail.com',
			        password: '141620'
			    }

			    cy.task('deleteUser', user.email)

			    cy.request({
			      url: '/users',
			      method: 'POST',
			      body: user,
			      failOnStatusCode: false
			    }).then(response => {
			      expect(response.status).to.eq(200)
		++++      cy.log(JSON.stringify(response.body))
			    })
			  })
			})	
		



		
=============================================================================================================================		
==========================================================        18. Plugin para testes de API              ====================================		
	
		### Instalar o plugin
			npm i cypress-plugin-api -D
		
		### importar o plugin no arquivo suporte / e2e
		
			
=============================================================================================================================		
==========================================================        19. Custom Commands             ====================================					
			
		Hoje temos apenas um unico caso de testes,  mas teremos mais cobertura e pra isso vamos implementar uma customer command preparando para 
		esse aumento de cobertura
		
		### caso de teste users.cy.js
		
			Dentro do do nosso users no final do codigo vamos implementar o nosso commands
			
			...
			
			})


			Cypress.Commands('postUser', (user) => {
			    Colar aqui
			})
		
		###  Vamos recortar  o nosso testes:
		
			cy.api({
			    url: '/users',
			    method: 'POST',
			    body: user,
			    failOnStatusCode: false
			  }).then(response => {
			    expect(response.status).to.eq(200)
			    cy.log(JSON.stringify(response.body))
			  })
		
		E colar dentro do command postUser, ficando assim:
		
					describe('POST /users', () =>{
					  it('register a new user', ()=>{

					    const user = {
					        name: 'margo',
					        email: 'margo@hotmail.com',
					        password: '141620'
					    }

					    cy.task('deleteUser', user.email)
					   
					  })
					})


					Cypress.Commands('postUser', (user) => {
					  cy.api({
					    url: '/users',
					    method: 'POST',
					    body: user,
					    failOnStatusCode: false
					  }).then(response => {
					    expect(response.status).to.eq(200)
					    cy.log(JSON.stringify(response.body))
					  })
					})
	
		### vamos modificar o call back da requisição com um retorno
		
			Cypress.Commands.add('postUser', (user) => {
			  cy.api({
			    url: '/users',
			    method: 'POST',
			    body: user,
			    failOnStatusCode: false
		                 +++  }).then(response => {
		                 +++    return response
			  })
			})

		####  Utilizando esse customer Command dentro da massa de teste
		
			cy.postUser(user)
			   .then(response => { response => {
			          expect(response.status).to.eq(200)
			       }
			
				
		### Vamos mover o command para o arquivo commands.js	
			
				Cypress.Commands.add('postUser', (user) => {
				  cy.api({
				    url: '/users',
				    method: 'POST',
				    body: user,
				    failOnStatusCode: false
			             		  }).then(response => {
			                   			  return response
				 	 })
				})
				
				
				
				
				
=============================================================================================================================		
==========================================================        20. Cobertura de testes	===================================				
			
	Em user.js que é o nosso teste, vamos duplicar o nosso teste e vamos modificar para o conflito 409 duplicated email!
	
		
			  it.only('duplicate email', ()=> {

			    const user = {
			        name: 'margo',
			        email: 'margo@hotmail.com',
			        password: '141620'
			    }
			    cy.task('deleteUser', user.email)

			    cy.postUser(user)
			    cy.postUser(user)
						.then(response => {

			        const {message} =  response.body;
						  expect(response.status).to.eq(409)
			        expect(message).to.equal('Duplicated email!')
						})  
			  })			
				
				
				
=============================================================================================================================		
==========================================================     21. Ganchos e campos obrigatórios  ==================================

		# Todos  os campos são obrigatórios
		
		
		### Validando o name, verificando status e message
							
				  context.only('required fields',() => {
				      const user = {
				        name: 'margo',
				        email: 'margo@hotmail.com',
				        password: '141620'
				    }

				    it('name is required',() => {

				      delete user.name

				      cy.postUser(user)
				        .then(response => {
				        
				          const { message } = response.body

				          expect(response.status).to.eq(400)
				          expect(message).to.eq('ValidationError: \"name\" is required')
				        })
				    })
				  })			

	### Validando email, criando um gancho com beforEach e reiniciado a massa teste em cada cenário
	
			it('email is required',() => {

			      delete user.email

			      cy.postUser(user)
			        .then(response => {

			          const { message } = response.body

			          expect(response.status).to.eq(400)
			          expect(message).to.eq('ValidationError: \"email\" is required')
			        })
			    })
		
	### Validando a senha 			
				
				
=============================================================================================================================		
==========================================================     22. Autenticação por Token               ==================================

	### Na pasta e2e vamos criar um novo arquivo chamado sessions.cy.js
	
	### POST session com sucesso
		describe('POST/sessions',  ()=>{
		
		    it('user session', ()=>{
		       

		        //massa de teste
		        const user = {
		            email: 'abmael_ninha@hotmail.com',
		            password: '141620'
		        }

		        cy.postSession(user)
		            .then(response => {
		                expect(response.status).to.eq(200)
		            })

		    })
		})

		Cypress.Commands.add('postSession', (user)=>{

		    cy.api({
		        url:'/sessions',
		        method:'POST',
		        body: user,
		    }).then(response => {
		        return response
		    })
		})
				
				
	######  Password Invalido
	
			
			    it('Invalid password', () => {

			         //massa de teste
			         const user = {
			            email: 'abmael_ninha@hotmail.com',
			            password: '14162'
			        }

			        cy.postSession(user)
			            .then(response => {
			                expect(response.status).to.eq(401)
			            })
			    })			
				
				
	#### Email invalido
	
			 it('Invalid email', () => {

			        //massa de teste
			        const user = {
			           email: 'abmael_ninha@hotmail.co',
			           password: '141620'
			       }

			       cy.postSession(user)
			           .then(response => {
			               expect(response.status).to.eq(401)
			           })
			   })	
			   
	#### Ajustando o commando para testar o name, mesmo que o não seja requisito para a authenticação
	
				
		Cypress.Commands.add('postSession', (user)=> {

		    cy.api({
		        url:'/sessions',
		        method:'POST',
		        body: {email:user.email, password: user.password},
		        failOnStatusCode:false,
		    }).then(response => {
		        return response
		    })		
	
	
	##### Ajustando o teste de sucesso da session para validar o name, email 
	
			 it('user session', ()=>{
			        //massa de teste
			        const userData = {
			            name: 'abmael',
			            email: 'abmael_ninha@hotmail.com',
			            password: '141620'
			        }

			        cy.postSession(userData)
			            .then(response => {

			                const {user} = response.body

			                expect(response.status).to.eq(200)
			                expect(user.name).to.eq(userData.name)
			                expect(user.email).to.eq(userData.email)
			            })
			    })	
			    
			    
			    
			    
			    
			    
			    
				
=============================================================================================================================		
==========================================================     23 . Controlando entrada e saida de dados              ==================================


	### Utilizando uma nova massa de teste para o testes de session
	
			describe('POST/sessions',  ()=>{

			    it('user session', ()=>{
			        //massa de teste
			        const userData = {
			++          name: 'jefferson',
			++          email: 'jefferson@hotmail.com',
			++          password: '141620'
			        }
			...
	### Mas identificamos que esse usuário não existe, por isso devemos chamar o metodo cypress    ->   cy.postUser(userData)

				describe('POST/sessions',  ()=>{

				    it('user session', ()=>{
				        //massa de teste
				        const userData = {
				            name: 'jefferson',
				            email: 'jefferson@hotmail.com',
				            password: '141620'
				        }

			+++	        cy.postUser(userData)

				        cy.postSession(userData)
				            .then(response => {

	###  O teste funciona, cria o usuário, mas se executarmos novamente, vamos verificar que  o teste POST  /users retorna um duplicated email, status code 409
	
	###  O teste passa pois não estamos fazendo nenhuma validação
	### Para corrigir, vamos chamar o vamos chamar a task cypress cy.task() antes do metodo cypress -> cy.postUser(userData), para deletar o usuário caso ele exista
	
		
		 it('user session', ()=> {
		 
		        //massa de teste
		        const userData = {
		            name: 'jefferson',
		            email: 'jefferson@hotmail.com',
		            password: '141620'
		        }

		+++    cy.task('deleteUser', userData.email)
		        cy.postUser(userData)

		        cy.postSession(userData)
		            .then(response => {

		                expect(response.status).to.eq(200)

		                const {user, token} = response.body

		                expect(user.name).to.eq(userData.name)
		                expect(user.email).to.eq(userData.email)
		                expect(token).not.to.be.empty  //Não deve ser vazio
		          })
		  })
	
		
		
=============================================================================================================================		
==========================================================     24. Fixtures & Funções do Javascript            ==================================
	
		### vamos criar dentro da pasta fixture um arquivo chamado users.json
		
				{
				  "sessions": {
				    "name": "jefferson",
				    "email": "jefferson@hotmail.com",
				    "password": "141620"
				  },

				  "inv_pass": {
				    "email": "abmael_ninha@hotmail.com",
				    "password": "14162"
				  },

				  "email_404": {
				    "email": "abma_ninha@hotmail.com",
				    "password": "141620"
				  }

				}

	### Vamos utilizar a fixture e nossa massa de testes sessions
	
	### No inicio do nosso teste user session, vamos chamar o nosso metodo fixture:
	
		 it('user session', ()=>{

		        cy.fixture('users').then(function(users) {
		        	// Aqui vamos colar toda a massa de teste e todas as espec referente a sessions 
		        }
		        
		        ...	

	### Ficando dessa forma:
	
				 cy.fixture('users').then(function(users){
				            //massa de teste
				            
				        const userData = {
				            name: 'jefferson',
				            email: 'jefferson@hotmail.com',
				            password: '141620'
				        }

				        cy.task('deleteUser', userData.email)
				        cy.postUser(userData)

				        cy.postSession(userData)
				            .then(response => {

				                expect(response.status).to.eq(200)

				                const {user, token} = response.body

				                expect(user.name).to.eq(userData.name)
				                expect(user.email).to.eq(userData.email)
				                expect(token).not.to.be.empty  //Não deve ser vazio
				            })
				        })

	### Agora ao inves de utilizarmos a massa de teste vamos fazer referencia a nossa fixture
	
	@@@ Antes vamos corrigir em users.json a massa session para login
	
	###  Agora vamos atribuir para a nossa constante userData o valor de json
	
			 it('user session', ()=>{

			        cy.fixture('users').then(function(users){
			            
			        //massa de teste que esta no fixture
			++++  const userData = users.login

			        cy.task('deleteUser', userData.email)
			        cy.postUser(userData)

			        cy.postSession(userData)
			            .then(response => {

			                expect(response.status).to.eq(200)

			                const {user, token} = response.body

			                expect(user.name).to.eq(userData.name)
			                expect(user.email).to.eq(userData.email)
			                expect(token).not.to.be.empty  //Não deve ser vazio
			            })
			        })
			    })

		##################################################################################################
		################## OBSERVAÇÃO: ESSA FORMA ACIMA É CORRETA QUE É FEITA NO CYPRESS PARA UTILIZAR AS FIXTURE ########
		################## AGORA VAMOS UTILIZAR UMA FORMA QUE O PROFESSOR EXEMPLIFICA, QUE MELHORA O ENTENDIMENTO###
		
		#### Vamos criar um beforEach e inicializaar a constante users como se fosse um construtor com o auxiliar this, dessa forma é possível acessá-lá em
		           todos os its
		
			describe('POST/sessions',  ()=>{

			    beforeEach(()=>{
			        cy.fixture('users').then(function(users){
			            this.users = users
			        })
			    })

		### Agora vamos retornar como era antes sem o fixture
		
		
			DE:
			
				 it.only('user session', ()=>{

			 retirar ----        cy.fixture('users').then(function(users) {
				            
				            //massa de teste que esta no fixture
				            const userData = users.login

				            cy.task('deleteUser', userData.email)
				            cy.postUser(userData)

				            cy.postSession(userData)
				                .then(response => {

					expect(response.status).to.eq(200)

					const {user, token} = response.body

					expect(user.name).to.eq(userData.name)
					expect(user.email).to.eq(userData.email)
					expect(token).not.to.be.empty  //Não deve ser vazio
				                })
			retirar  ---         })
				 })
			 PARA :
			 
			 		 it.only('user session', ()=>{

					            
					            //massa de teste que esta no fixture
					            const userData = users.login

					            cy.task('deleteUser', userData.email)
					            cy.postUser(userData)

					            cy.postSession(userData)
					                .then(response => {

						expect(response.status).to.eq(200)

						const {user, token} = response.body

						expect(user.name).to.eq(userData.name)
						expect(user.email).to.eq(userData.email)
						expect(token).not.to.be.empty  //Não deve ser vazio
					                })
					    })
			

		### Ajustando o Invalid password
		
			DE:  
			
				 it('Invalid password', () => {

				         //massa de teste
				         const user = {
				            email: 'abmael_ninha@hotmail.com',
				            password: '14162'
				        }

				        cy.postSession(user)
				            .then(response => {
				                expect(response.status).to.eq(401)
				            })
				    })

			PARA :
			
				  it('Invalid password', () => {

				         //massa de teste
				         const user = this.users = users.inv_pass

				        cy.postSession(user)
				            .then(response => {
				                expect(response.status).to.eq(401)
				            })
				    })

		####  Ajustando o  Invalid email
		
			it('Invalid email', () => {

			        //massa de teste
			        const user = this.users =  users.email_404

			       cy.postSession(user)
			           .then(response => {
			               expect(response.status).to.eq(401)
			           })
			   })

		####  Não é possível pois o javascript diz que o this.users é undefined, pois as funções devem ser convecionais com a palavra reservada function
		
			Retiramos os arraon function dos its e do before para que seja possível executar os testes com as fixture iniciadas como construtor no
			beforEaach
			
				describe('POST/sessions',  ()=>{

				    beforeEach(function() {
				        cy.fixture('users').then(function(users){
				            this.users = users
				        })
				    })

				    it('user session', function() {
				            
				        //massa de teste que esta no fixture
				        const userData = this.users.login

				        cy.task('deleteUser', userData.email)
				        cy.postUser(userData)

				        cy.postSession(userData)
				            .then(response => {

				                expect(response.status).to.eq(200)

				                const {user, token} = response.body

				                expect(user.name).to.eq(userData.name)
				                expect(user.email).to.eq(userData.email)
				                expect(token).not.to.be.empty  //Não deve ser vazio
				            })
				    })

				    it('Invalid password', function() {

				          //massa de teste que esta no fixture
				         const user = this.users.inv_pass

				        cy.postSession(user)
				            .then(response => {
				                expect(response.status).to.eq(401)
				            })
				    })

				    it('Invalid email', function() {

				         //massa de teste que esta no fixture
				        const user = this.users.email_404

				       cy.postSession(user)
				           .then(response => {
				               expect(response.status).to.eq(401)
				           })
				   })


				})
	
	############## Foi ajustado a fixture user para receber a massa de dados dos testes de cadastro
	
			Adicionado no fim do arquivo
			
				"create": {
				      "name": "margo",
				      "email": "margo@hotmail.com",
				      "password": "141620"
				    },
				    "dup_email": {
				      "name": "margo",
				      "email": "margo@hotmail.com",
				      "password": "141620"
				    },
				    "required": {
				      "name": "margo",
				      "email": "margo@hotmail.com",
				      "password": "141620"
				    }
	#### Ajustamos todo o codigo do teste de cadastro de usuarios users.cy.js
	
				describe('POST /users', () =>{

				  beforeEach(function() {
				    cy.fixture('users').then(function(users){
				        this.users = users
				    })
				})

				  it('register a new user', function() {

				    const user = this.users.create

				    cy.task('deleteUser', user.email)

				    cy.postUser(user)
							.then(response => {
							  expect(response.status).to.eq(200)
							})
				   
				  })


				  it('duplicate email', function() {

				    const user = this.users.dup_email
				    cy.task('deleteUser', user.email)

				    cy.postUser(user)
				    cy.postUser(user)
							.then(response => {

				        const {message} =  response.body;
							  expect(response.status).to.eq(409)
				        expect(message).to.equal('Duplicated email!')
							})  
				  })

				  context('required fields',function()  {

				    let user;

				    // Esse gancho sempre será executado quando houver um it(cenário)
				    beforeEach(function() {
				      user = this.users.required
				    })

				    it('name is required',function()  {

				      delete user.name

				      cy.postUser(user)
				        .then(response => {

				          const { message } = response.body

				          expect(response.status).to.eq(400)
				          expect(message).to.eq('ValidationError: \"name\" is required')
				        })
				    })

				    it('email is required',function()  {

				      delete user.email

				      cy.postUser(user)
				        .then(response => {

				          const { message } = response.body

				          expect(response.status).to.eq(400)
				          expect(message).to.eq('ValidationError: \"email\" is required')
				        })
				    })


				    it('password is required',function()  {

				      delete user.password

				      cy.postUser(user)
				        .then(response => {

				          const { message } = response.body

				          expect(response.status).to.eq(400)
				          expect(message).to.eq('ValidationError: \"password\" is required')
				        })
				    })

				  })
				})


=============================================================================================================================		
==========================================================    25. Testando com token          ==================================	

	####  Testando pela insominia
	
	REQUEST
		POST http://localhost:3333/tasks
		BODY JSON
		
			{
				"name": "Pagar minhas contas",
				"tags": [
					"nubank",
					"smail",
					"ourocard"
				]
			}
		HEADERS 
		
				Content-Type
				application/json


				User-Agent
				insomnia/8.6.1


				Authorization	
					  eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6IjY2MWU4MjkxMjFlOGExZjBhYzkwYzUx
					   YyIsInVzZXIiOnsiX2lkIjoiNjYxZTgyOTEyMWU4YTFmMGFjOTBj 
					   NTFjIiwibmFtZSI6ImFibWFlbCIsImVtYWlsIjoiYWJtYWVsX25pbmhhQ
					   GhvdG1haWwuY29tIiwicGFzc3dvcmQiOiIkMmIkMDgkRDVHbVpMVGpIZUMvQlVoblRNQ0FW
					   ZWRXbFR5WEtVSGk1V3JIaWxHckl6QWh3Zm9uTHhPLzIifSwiaWF0IjoxNzEzOTAwMTExLCJleHAiO
					   jE3MTQ3NjQxMTF9.avKA1SMA69wdYd2PiddkuxW6YuExHruNcVgvNeI1KZo
	RESPONSE
	
		PREVIEW
		
			{
				"name": "Pagar minhas contas",
				"is_done": false,
				"tags": [
					"nubank",
					"smail",
					"ourocard"
				],
				"user": "661e829121e8a1f0ac90c51c",
				"_id": "66291765463386d60bef123b"
			}
		
		
=============================================================================================================================		
==========================================================    26. Adicionando o token no header            ==================================	

	### Criando uma nova Swit de teste chamada task
	
		describe('POST /task', () => {

		    it('register a new task', function() {
		        
		    })
		    
		})
		
		
		
	### Criand a fixture task
	
	Dentro de fixture vamos criar  um arquivo chamado tasks.json
	
		{
		    "create": {
		        "user": {
		            "name": "jefferson",
		            "email": "jefferson@hotmail.com",
		            "password": "141620"
		        },
		        "task": {
		            "name": "Pagar a fatura do cartão",
		            "tags": [
		                "nubank",
		                "smiles",
		                "ourocard"
		            ]
		        }
		    }
		}

	### Retornando ao nosso teste
	
			describe('POST /task', () => {

		   beforeEach(function () {
		    cy.fixture('tasks').then(function (){
		        this.tasks =  tasks
		    })
		   })

		    it('register a new task', function() {
		        
		        const { user, task } = this.tasks.create
		        cy.api({
		            url: '/tasks',
		            method: 'POST',
		            body: task,
		            failOnStatusCode: false
		        }).then(response => {
		            expect(response.status).to.eq(200)
		        })
		    })
		})
		
	####  Com esse nosso teste dessa forma obtivemos um retono 401 Unauthorized
	
		
		assertexpected 401 to equal 200
		
		
			AssertionError
			expected 401 to equal 200
			cypress/e2e/tasks.cy.js:18:40
			  16 |             failOnStatusCode: false
			  17 |         }).then(response => {
			> 18 |             expect(response.status).to.eq(200)
			     |                                        ^
			  19 |         })
			  20 |     })
			  21 | 


	####  Ajustando para receber o token armazenar e utilizar no register a new task
	
	
			describe('POST /task', () => {

			   beforeEach(function () {
			    cy.fixture('tasks').then(function (tasks){
			        this.tasks =  tasks
			    })
			   })

			    it('register a new task', function() {
			        
			        const { user, task } = this.tasks.create
			        
			###################
			#
			#   RELEMBRANDO COMO FUNCIONA O COMMAND 	'postSession'
			#					
			#	Cypress.Commands.add('postSession', (user)=> {
			#
			#	  cy.api({
			#	      url:'/sessions',
			#	      method:'POST',
			#	      body: {email:user.email, password: user.password},
			#	      failOnStatusCode:false,
			#	  }).then(response => {
			#	      return response
			#	  })
			#
			#	})
			#######################
			
			        cy.postSession(user)
			            .then(response => {
			                cy.log(response.body.token)

			                cy.api({
				url: '/tasks',
				method: 'POST',
				body: task,
				headers: {
				    authorization: response.body.token
				},
				failOnStatusCode: false
			                }).then(response => {
				expect(response.status).to.eq(200)
			                })
			                Cypress.env('token', response.body.token)
			            })
    
			    })

			})


		
=============================================================================================================================		
==========================================================    27. Qualidade dos dados            ==================================	

	### Para garantir assertividade do teste é importante remover a tarefa antes de cadastrar, pois estamos usando massa de teste fixa
	
	### Vamosa cessar o arquivo cypress.config.js 
		Vamos criar uma nova tarefa abaixo da tarefa deleteUser
		
			
				const { defineConfig } = require("cypress");
				const {connect } = require('./cypress/support/mongo')
				require('dotenv').config()


				module.exports = defineConfig({
				  e2e: {
				   async  setupNodeEvents(on, config) {
				      // implement node event listeners here

				      const db = await connect();

				      on('task', {

				       async deleteUser(email) {
				          const users = db.collection('users')
				          await users.deleteMany({email: email})
				          return null;
				        },
				        async deleteTask(tasksName) {
				          const tasks = db.collection('tasks')
				          await tasks.deleteMany({name: tasksName})
				          return null;
				        }
				      })
				    },
				    baseUrl: "http://localhost:3333"
				  },
				});

	### Agora em nossa switch register a new task dentro do postSession antes da chamada da api, vamos chamar a nossa função task chamada 
	        deleteTask passando o task.name
	        
	        	...
	        	
		        	cy.postSession(user)
			            .then(response => {

			                cy.api({
				url: '/tasks',
				method: 'POST',
				body: task,
				headers: {
				    authorization: response.body.token
				},
				failOnStatusCode: false
			                }).then(response => {
				expect(response.status).to.eq(200)
			                })
			                Cypress.env('token', response.body.token)
			  })
	                 ...
	                 
	###      Tornando nosso testes idependente, pois caso alguem exclui-a o usuário do bd o nosso teste ira recriar e se existir ira delear
	
				describe('POST /task', () => {

				   beforeEach(function () {
				    cy.fixture('tasks').then(function (tasks){
				        this.tasks =  tasks
				    })
				   })

				    it('register a new task', function() {
				        
				        const { user, task } = this.tasks.create

				        cy.task('deleteUser', user.email)
				        cy.postUser(user)

				        cy.task('deleteTask', task.name)

				        cy.postSession(user)
				            .then(response => {

				                cy.api({
					url: '/tasks',
					method: 'POST',
					body: task,
					headers: {
					    authorization: response.body.token
					},
					failOnStatusCode: false
				                }).then(response => {
					expect(response.status).to.eq(200)
				                })
				                Cypress.env('token', response.body.token)
				            })

				        
				    })

				})             
	
 	####  Resolvendo o problema caso alguem  crie uma tarefa com o mesmo nome os nossos testes ira deletar todas
 	
 	## Vamos acessar o cypress.config.js
 		
								
			const { defineConfig } = require("cypress");
			const {connect } = require('./cypress/support/mongo')
			require('dotenv').config()


			module.exports = defineConfig({
			  e2e: {
			   async  setupNodeEvents(on, config) {
			      // implement node event listeners here

			      const db = await connect();

			      on('task', {

			       async deleteUser(email) {
			          const users = db.collection('users')
			          await users.deleteMany({email: email})
			          return null;
			        },
			        async deleteTask(tasksName, emailUser) {

			          const users = db.collection('users')

			          const user =  users.findOne({email: emailUser})

			          const tasks = db.collection('tasks')
			          await tasks.deleteMany({name: tasksName, user: user._id})
			          return null;
			        }
			      })
			    },
			    baseUrl: "http://localhost:3333"
			  },
			});


	### Agora  em nosso testes  task  dentro do postSession, no momento que vamos deletar uma task vamos passar também user.email

						
			    it('register a new task', function() {
			        
			        const { user, task } = this.tasks.create

			        cy.task('deleteUser', user.email)
			        
			        cy.postUser(user)        

			        cy.postSession(user)
			            .then(response => {
			                cy.task('deleteTask', task.name, user.email)

			                cy.api({
				url: '/tasks',
				method: 'POST',
				body: task,
				headers: {
				    authorization: response.body.token
				},
				failOnStatusCode: false
			                }).then(response => {
				expect(response.status).to.eq(200)
			                })
			                Cypress.env('token', response.body.token)
			            })
			    })

	### Agora vamos organizar nosso codigo
		## vamos começar retirando cy.api e movento para o command
		
			

=============================================================================================================================		
==========================================================    28. Validando response body            ===================================

	### Adicionamos mais validações no registre a new task validando o name e as tags, 
	
			const { user, task } = this.tasks.create

			        cy.task('deleteUser', user.email)

			        cy.postUser(user)

			        cy.postSession(user)
			            .then(response => {
			                cy.task('deleteTask', task.name, user.email)

			                cy.postTask(task, response.body.token)
				.then(response => {
				    expect(response.status).to.eq(200)
				    expect(response.body.name).to.eq(task.name)
				    expect(response.body.tags).to.eq(task.tags)
				})

			                // Cypress.env('token', response.body.token)
			            })


			    })

			})

	
	#### Mas o cypres retorna um erro informando que a comparação dos dados das tags estão divergentes  pois o cypress esta se preocupando com as tipages
	
			assertexpected [ nubank, smiles, ourocard ] to equal [ nubank, smiles, ourocard ]
			AssertionError
			expected [ 'nubank', 'smiles', 'ourocard' ] to equal [ 'nubank', 'smiles', 'ourocard' ]
	
	
			it('register a new task', function () {

			        
	#### Para resolver nesse momento vamos alterar o seletor de comparação de igualdade no expect de: "eq"  para: "eql"

		expect(response.body.tags).to.eql(task.tags)
		
	####  O  response de task, nos retorna os seguintes dados:
	
			{
			  "name": "Pagar a fatura do cartão",
			  "is_done": false,
			  "tags": [
			    "nubank",
			    "smiles",
			    "ourocard"
			  ],
			  "user": "66296d02463386d60bef1325",
			  "_id": "66296d02463386d60bef1329"
			}

	### Vamos validar o campo is_done, pois o mesmo na criação será sempre false
	
	### Para isso em register a new task na chamada postTask vamos adicionar um expect
	
			it('register a new task', function () {

			        const { user, task } = this.tasks.create

			        cy.task('deleteUser', user.email)

			        cy.postUser(user)

			        cy.postSession(user)
			            .then(response => {
			                cy.task('deleteTask', task.name, user.email)

			                cy.postTask(task, response.body.token)
				.then(response => {
				    expect(response.status).to.eq(200)
				    expect(response.body.name).to.eq(task.name)
				    expect(response.body.tags).to.eql(task.tags)
				    expect(response.body.is_done).to.be.false
				})

			                // Cypress.env('token', response.body.token)
			            })

			    })
	
	### Também temos o campo user, vamos adicionar mais um expect e pegar o response do usuário comparando com o response da session
		### obs, foi necessário alterar o nome da variavel responso da session pois os nomes estavam iguais, response
		
			it('register a new task', function () {

			        const { user, task } = this.tasks.create

			        cy.task('deleteUser', user.email)

			        cy.postUser(user)

			        cy.postSession(user)
			            .then(userResp => {
			                cy.task('deleteTask', task.name, user.email)

			                cy.postTask(task, userResp.body.token)
				.then(response => {
				    expect(response.status).to.eq(200)
				    expect(response.body.name).to.eq(task.name)
				    expect(response.body.tags).to.eql(task.tags)
				    expect(response.body.is_done).to.be.false
				    expect(response.body.user).to.eq(userResp.body._id)
				})

			                // Cypress.env('token', response.body.token)
			            })

			    })
	
	
	## valindando o indentificador da tarefa
	
	## vamos contar as quantidades de caracteres do id
	
		it('register a new task', function () {

		        const { user, task } = this.tasks.create

		        cy.task('deleteUser', user.email)

		        cy.postUser(user)

		        cy.postSession(user)
		            .then(userResp => {
		                cy.task('deleteTask', task.name, user.email)

		                cy.postTask(task, userResp.body.token)
			.then(response => {
			    expect(response.status).to.eq(200)
			    expect(response.body.name).to.eq(task.name)
			    expect(response.body.tags).to.eql(task.tags)
			    expect(response.body.is_done).to.be.false
			    expect(response.body.user).to.eq(userResp.body.user._id)
			    expect(response.body._id.length).to.eq(24)
			})

		                // Cypress.env('token', response.body.token)
		            })

		    })
	
	
	

=============================================================================================================================		
==========================================================   29. Tarefa duplicada          ===================================	
	
			
	
	
	
	
	
	
	
	

